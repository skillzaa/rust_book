<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="welcome.html">Welcome</a></li><li class="chapter-item expanded affix "><a href="faqs/questions.html">FAQs</a></li><li class="chapter-item expanded affix "><li class="part-title">Rust Basics</li><li class="spacer"></li><li class="chapter-item expanded "><a href="basics/index.html"><strong aria-hidden="true">1.</strong> Basics Index</a></li><li class="chapter-item expanded "><a href="basics/printing_arrays.html"><strong aria-hidden="true">2.</strong> Printing arrays</a></li><li class="chapter-item expanded "><a href="basics/vertors_in_rust_part1.html"><strong aria-hidden="true">3.</strong> Vertors in Rust Part1</a></li><li class="chapter-item expanded "><a href="basics/vertors_in_rust_part2.html"><strong aria-hidden="true">4.</strong> Vertors in Rust Part2</a></li><li class="chapter-item expanded "><a href="basics/vertors_in_rust_part3.html"><strong aria-hidden="true">5.</strong> Vertors in Rust Part3</a></li><li class="chapter-item expanded "><a href="basics/custom_error_type.html"><strong aria-hidden="true">6.</strong> Custom Error Type</a></li><li class="chapter-item expanded "><a href="basics/duration_between_two_points_of_time.html"><strong aria-hidden="true">7.</strong> Duration Between Points of Time</a></li><li class="chapter-item expanded "><a href="basics/hashmap01.html"><strong aria-hidden="true">8.</strong> Hashmap 01</a></li><li class="chapter-item expanded "><a href="basics/hashmap02.html"><strong aria-hidden="true">9.</strong> Hashmap 02</a></li><li class="chapter-item expanded "><a href="basics/result_consumed.html"><strong aria-hidden="true">10.</strong> Result Consumed</a></li><li class="chapter-item expanded "><a href="basics/some_none_example.html"><strong aria-hidden="true">11.</strong> Some None Example</a></li><li class="chapter-item expanded "><a href="basics/struct_impl_example.html"><strong aria-hidden="true">12.</strong> Struct Impl Example</a></li><li class="chapter-item expanded "><a href="basics/struct_impl02_example.html"><strong aria-hidden="true">13.</strong> Struct Impl Example-02</a></li><li class="chapter-item expanded "><a href="basics/struct_impl02_example.html"><strong aria-hidden="true">14.</strong> Struct Impl Example-02</a></li><li class="chapter-item expanded "><a href="basics/struct_printing.html"><strong aria-hidden="true">15.</strong> Struct Printing</a></li><li class="chapter-item expanded "><a href="basics/struct_to_function.html"><strong aria-hidden="true">16.</strong> Sending Struct to a Function</a></li><li class="chapter-item expanded "><a href="basics/system_time.html"><strong aria-hidden="true">17.</strong> System Time / Time Stamp</a></li><li class="chapter-item expanded "><a href="basics/thread_sleep.html"><strong aria-hidden="true">18.</strong> Thread Sleep</a></li><li class="chapter-item expanded "><a href="basics/documentation.html"><strong aria-hidden="true">19.</strong> Documentation</a></li><li class="chapter-item expanded "><a href="basics/helpful_git_commands.html"><strong aria-hidden="true">20.</strong> Helpful git commands</a></li><li class="chapter-item expanded "><a href="basics/creating_file.html"><strong aria-hidden="true">21.</strong> Creating File</a></li><li class="chapter-item expanded "><a href="basics/reading_file.html"><strong aria-hidden="true">22.</strong> Reading File</a></li><li class="chapter-item expanded "><a href="basics/serde_ser_deser.html"><strong aria-hidden="true">23.</strong> Serde json</a></li><li class="chapter-item expanded "><a href="basics/regex.html"><strong aria-hidden="true">24.</strong> Quick n Dirty Regex</a></li><li class="chapter-item expanded affix "><li class="part-title">Rought Notes</li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="misc/2021_oct_21_graphics.html">State of Multimedia Programming</a></li><li class="chapter-item expanded affix "><a href="rough_notes/2021-oct-15-notes.html">2021-oct-15 Notes</a></li><li class="chapter-item expanded affix "><a href="rough_notes/2021-oct-16-traits.html">2021-oct-16 Traits in Rust</a></li><li class="chapter-item expanded affix "><a href="rough_notes/2021-oct-18-notes.html">2021-oct-18 Notes</a></li><li class="chapter-item expanded affix "><a href="faqs/questions.html">FAQs</a></li><li class="chapter-item expanded affix "><a href="misc/one_line_life_savers.html">One line life savers</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#welcome-to-my-rust-book" id="welcome-to-my-rust-book">Welcome to My Rust Book</a></h1>
<h6><a class="header" href="#29-july-2021-also-14-oct-2021" id="29-july-2021-also-14-oct-2021">29 July 2021 (also 14-Oct-2021)</a></h6>
<hr />
<hr />
<p>In the Name of Allah Most Merciful.</p>
<ul>
<li>I have started this new project to write about Rust Programming language. </li>
<li>Hopefully I will continue this project for a very long time. (20-Oct-2021) <strong>I promise my-self that I will not move this project from its current plateform i.e mdBook and github</strong>. </li>
<li>These are my notes which I created while learning and coding Rust language. It has code snippets , images , explanations, rants and everthing that I wrote while learning rust.</li>
<li>Consider this as a <strong>quick and dirty -- but -- detailed</strong> sort of a work. I expect there to be many mistakes and errors and hope that you will bring them to my attention.</li>
<li>There will be rough notes (they are like scrambling) please dont waste your time on those.</li>
<li>God bless you. </li>
</ul>
<hr />
<p>you can contact me on::
Twitter <a href="https://twitter.com/rustntell">@rustntell</a></p>
<h1><a class="header" href="#faqs" id="faqs">FAQs</a></h1>
<ol>
<li>What is the difference between an array in rust and tuples.</li>
</ol>
<h1><a class="header" href="#basic-rust-articles" id="basic-rust-articles">Basic Rust Articles</a></h1>
<ul>
<li><a href="basics/./printing_arrays.html">Printing arrays</a> </li>
<li><a href="basics/./vertors_in_rust_part1.html">Vertors in Rust Part1</a></li>
<li><a href="basics/./vertors_in_rust_part2.html">Vertors in Rust Part2</a></li>
<li><a href="basics/./custom_error_type.html">Custom Error Type</a></li>
<li><a href="basics/./duration_between_two_points_of_time.html">Duration Between Points of Time</a></li>
<li><a href="basics/./hashmap01.html">Hashmap 01</a></li>
<li><a href="basics/./hashmap02.html">Hashmap 02</a></li>
<li><a href="basics/./result_consumed.html">Result Consumed</a></li>
<li><a href="basics/./some_none_example.html">Some None Example</a></li>
<li><a href="basics/./struct_impl_example.html">Struct Impl Example</a></li>
<li><a href="basics/./struct_impl02_example.html">Struct Impl Example-02</a></li>
<li><a href="basics/./struct_printing.html">Struct Printing</a></li>
<li><a href="basics/./struct_to_function.html">Struct to Function</a></li>
<li><a href="basics/./system_time.html">System Time</a></li>
</ul>
<hr />
<p><a href="basics/./helpful_git_commands.html">Helpful git commands</a> 
<a href="basics/./possible_future_projects.html">Possible Future Projects</a> 
<a href="basics/./development_diary.html">Development Diary</a> </p>
<h1><a class="header" href="#pringting-arrays-in-rust" id="pringting-arrays-in-rust">Pringting Arrays in Rust</a></h1>
<p>Lets look at the simple task of printing an array to terminal:</p>
<pre><pre class="playground"><code class="language-rust">
  fn main(){

    let a: [i32; 5] = [1, 2, 3, 4, 5];
    println!(&quot;{}&quot;,a);

}//--main

</code></pre></pre>
<p>We are getting an error about printing a.</p>
<pre><code>i32; 5]
let a: [i32; 5] = [1, 2, 3, 4, 5];
`[i32; 5]` doesn't implement `std::fmt::Display`

`[i32; 5]` cannot be formatted with the default formatter

help: the trait `std::fmt::Display` is not implemented for `[i32; 5]`
</code></pre>
<p>Display is a trait. To be printed out by println macro, the object needs to implement this trait.
We can still print the array since println also use another trait for printing and that is &quot;Debug&quot; trait. To need to tell the println macro to use the Debug implementation and print the object. For this we just have to chage following:</p>
<pre><code>    println!(&quot;{:?}&quot;,a);
</code></pre>
<h1><a class="header" href="#vectors-in-rust-part-1" id="vectors-in-rust-part-1">Vectors in Rust part-1</a></h1>
<p>I have been reading about rust for a while now and the way I can explain vectors in rust is ::</p>
<blockquote>
<p>Vectors are just like arrays i.e they are a linear collection of similar objects But Vectors unlike arrays are allocated on heap and can grow or shrink.</p>
</blockquote>
<p>So this tell us that in case of a vector as well as array we need to know the data type that has to be stored in it BUT in case of array we also need to know the total number of items where as incase of a vector we dont need that.</p>
<hr />
<p>From the Rust Book:: chapter 8 :: Common Collections</p>
<blockquote>
<p>Rust’s standard library includes a number of very useful data structures called collections Most other data types represent one specific value, but collections can contain multiple values. Unlike the built-in array and tuple types, the data these collections point to is stored on the heap, which means the amount of data does not need to be known at compile time and can grow or shrink as the program runs. Each kind of collection has different capabilities and costs, and choosing an appropriate one for your current situation is a skill you’ll develop over time.
also
vectors are indexed by number, starting at zero.</p>
</blockquote>
<h3><a class="header" href="#among-the-most-important-collections-are" id="among-the-most-important-collections-are">Among the most important collections are:</a></h3>
<ul>
<li>Vectors</li>
<li>Strings</li>
<li>Hash maps </li>
</ul>
<h2><a class="header" href="#vectors-in-rust" id="vectors-in-rust">Vectors in Rust</a></h2>
<blockquote>
<p>Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type. They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart.</p>
</blockquote>
<h2><a class="header" href="#creating-a-new-vector" id="creating-a-new-vector">Creating a new Vector</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;i32&gt; = Vec::new();
or
let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Vectors are implemented using generics</p>
</blockquote>
<h2><a class="header" href="#updating-a-vector" id="updating-a-vector">Updating a Vector</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let mut v:Vec&lt;i32&gt; = Vec::new();
v.push(5);
v.push(6);
v.push(7);
v.push(8);
println!(&quot;{:?}&quot;,v);
println!(&quot;vector Capacity :: {:?}&quot;,v.capacity());
println!(&quot;vector Capacity :: {:?}&quot;,v.len());
}
</code></pre></pre>
<ul>
<li>Result is capacity = 4 , len = 4</li>
</ul>
<blockquote>
<p>The internal implementation of vector is such that it is just a struct which holds a pointer to heap allocated data. the length and capacity properties are &quot;impl&quot; on to this structure.</p>
</blockquote>
<h2><a class="header" href="#reading-data-from-a-vector" id="reading-data-from-a-vector">Reading Data from a Vector</a></h2>
<p>We can read data from a vector directly using a reference or using a get method. Lets check the get method with out using pattern matching (which is not advisable).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
let mut v:Vec&lt;u32&gt; = Vec::new();

v.push(1);
v.push(2);
v.push(3);
v.push(4);
v.push(5);

println!(&quot;1:: {:?}&quot;,v.get(1));
println!(&quot;2:: {:?}&quot;,v.get(2));
println!(&quot;3:: {:?}&quot;,v.get(3));

}
</code></pre></pre>
<p>The Result is </p>
<pre><code>1:: Some(2)
2:: Some(3)
3:: Some(4)
</code></pre>
<h3><a class="header" href="#lets-look-at-correct-way-using-pattern-matching" id="lets-look-at-correct-way-using-pattern-matching">lets look at correct way using pattern matching</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!(&quot;The third element is {}&quot;, third);

    match v.get(2) {
        Some(third) =&gt; println!(&quot;The third element is {}&quot;, third),
        None =&gt; println!(&quot;There is no third element.&quot;),
    }
}
</code></pre></pre>
<p>The main point to understand is that while using &amp;i32 we get a reference and while using &quot;get&quot; method we get Option&lt;&amp;T&gt;. Thus making the &quot;get&quot; method very safe.
Both of these methods behave very differently incase an index is called that does not exist.</p>
<h2><a class="header" href="#side-trip--lets-look-at-the-above-code-again-from-pattern-matching-point-of-view" id="side-trip--lets-look-at-the-above-code-again-from-pattern-matching-point-of-view">Side Trip :: Lets look at the above code again from pattern matching point of view</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!(&quot;The third element is {}&quot;, third);

    match v.get(2) {
        Some(t) =&gt; println!(&quot;The third element is {}&quot;, t),
        None =&gt; println!(&quot;There is no third element.&quot;),
    }
}
</code></pre></pre>
<blockquote>
<p>when we use get we getback an enum type called &quot;option&quot;. This enum has 2 variants &quot;Some&quot; and &quot;None&quot;. The sum is a method where as None show the presence of nothing.
Options are commonly paired with pattern matching to query the presence of a value and take action, always accounting for the None case.
Incase we call an index which does not exist e.g &quot;&amp;v[500]&quot; , this will panic, However while using &quot;get&quot; and &quot;match&quot; it will continue working fine.</p>
</blockquote>
<hr />
<p>In the above code argument name of the Some inside match block does not matter. What ever has been returned will be handed over to what ever name you place in the parenthesis after Some (in this case we have &quot;t&quot;).</p>
<h2><a class="header" href="#-lets-get-back-to-vectors-in-part-2" id="-lets-get-back-to-vectors-in-part-2">... lets get back to vectors in part-2</a></h2>
<h1><a class="header" href="#vectors-in-rust-part-2" id="vectors-in-rust-part-2">Vectors in Rust part-2</a></h1>
<p>Lets look at the following code. This will not compile.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let mut v:Vec&lt;i32&gt; = vec![1,2,3,4,5];
   //==== Immutable borrow 
   let first = &amp;v[0];
   //==== Mutable borrow
   v.push(6);
   println!(&quot;first{}&quot;,first);
}
</code></pre></pre>
<blockquote>
<p>We can not have a mutable borrow and a non mutable borrow in the same scope.Adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn’t enough room to put all the elements next to each other where the vector currently is. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.</p>
</blockquote>
<hr />
<h2><a class="header" href="#iterating-over-the-values-in-a-vector" id="iterating-over-the-values-in-a-vector">Iterating over the Values in a Vector</a></h2>
<p>We can do it like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let v = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{}&quot;, i);
    }
<span class="boring">}
</span></code></pre></pre>
<p>OR</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
  }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#using-an-enum-to-store-multiple-types" id="using-an-enum-to-store-multiple-types">Using an Enum to Store Multiple Types</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#vertors-in-rust-part3" id="vertors-in-rust-part3">Vertors in Rust Part3</a></h1>
<p>Following topics are intended to be covered</p>
<ol>
<li>creating vector</li>
<li>Referencing items </li>
<li>Iterating over vec, three ways.</li>
<li>Extract a vector out of another vector (using filters and collect).</li>
</ol>
<h2><a class="header" href="#creating-a-vector" id="creating-a-vector">Creating a vector</a></h2>
<p>Basically has two  methods</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = vec![1,2,3,4,5];
let y:Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#referencing-a-vector-items" id="referencing-a-vector-items">Referencing a vector items</a></h2>
<p>Basically has two  methods</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let third: &amp;i32 = &amp;v[2]; //=====&gt; strange but often used
 //and  
 let x = v.get(2) //===&gt; will return Option
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#iterating-over-vec" id="iterating-over-vec">Iterating over vec</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3, 4, 5];

for i in &amp;v {
    println!(&quot;A reference to {}&quot;, i);
}

for i in &amp;mut v {
    println!(&quot;A mutable reference to {}&quot;, i);
}

for i in v {
    println!(&quot;Take ownership of the vector and its element {}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#using-filters" id="using-filters">Using Filters</a></h2>
<p>We can extract a vector out of another vector using filter and collect.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: Vec&lt;i32&gt; = vec![
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
];

let even_numbers = numbers
  .into_iter()
  .filter(|n| n % 2 == 0)
  .collect::&lt;Vec&lt;_&gt;&gt;();

println!(&quot;{:?}&quot;, even_numbers);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#future-projects" id="future-projects">Future Projects</a></h3>
<ol start="6">
<li>check if a vec has some items of another vector (overlap).</li>
<li>check if a vec has some items of another vector (superset).</li>
<li>check if a vec is subset of another vec (subset).</li>
<li>sort a vec.</li>
<li>comparing two vectors.</li>
</ol>
<h1><a class="header" href="#custom-error-type" id="custom-error-type">Custom Error Type</a></h1>
<p>This is just an example</p>
<pre><pre class="playground"><code class="language-rust">use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct SuperError {
    side: SuperErrorSideKick,
}

impl fmt::Display for SuperError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;SuperError is here!&quot;)
    }
}

impl Error for SuperError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        Some(&amp;self.side)
    }
}

fn main() {
    match get_super_error() {
        Err(e) =&gt; {
            println!(&quot;Error: {}&quot;, e);
            println!(&quot;Caused by: {}&quot;, e.source().unwrap());
        }
        _ =&gt; println!(&quot;No error&quot;),
    }
}
</code></pre></pre>
<h1><a class="header" href="#duration-between-two-points-of-time" id="duration-between-two-points-of-time">Duration Between Two Points of Time</a></h1>
<pre><pre class="playground"><code class="language-rust">use std::time::SystemTime;
fn main() {

    let sys_time = SystemTime::now();
    // println!(&quot;{:?}&quot;,sys_time.tv_sec);
    let new_sys_time = SystemTime::now();
    let difference = new_sys_time.duration_since(sys_time)
        .expect(&quot;Clock may have gone backwards&quot;);
    println!(&quot;{:?}&quot;, difference);
}
</code></pre></pre>
<h1><a class="header" href="#hash-map---part-1" id="hash-map---part-1">Hash Map - Part 1</a></h1>
<pre><pre class="playground"><code class="language-rust">fn main(){
use std::collections::HashMap;
let mut hm:HashMap &lt;String,u128&gt; = HashMap::new();

hm.insert(&quot;one&quot;.to_string(),1);
hm.insert(&quot;two&quot;.to_string(),2);
hm.insert(&quot;three&quot;.to_string(),3);
hm.insert(&quot;four&quot;.to_string(),4);
hm.insert(&quot;five&quot;.to_string(),5);

for (key, value) in &amp;hm {
    println!(&quot;{}: {}&quot;, key, value);
}



}
</code></pre></pre>
<h1><a class="header" href="#hash-map---part-2" id="hash-map---part-2">Hash Map - Part 2</a></h1>
<pre><pre class="playground"><code class="language-rust">fn main(){
    use std::collections::HashMap;
    #[derive(Hash, Eq, PartialEq, Debug)]
        struct Viking {
            name: String,
            country: String,
        }
        
        impl Viking {
            /// Creates a new Viking.
            fn new(name: &amp;str, country: &amp;str) -&gt; Viking {
                Viking { name: name.to_string(), country: country.to_string() }
            }
        }
        
        // Use a HashMap to store the vikings' health points.
        let mut vikings:HashMap&lt;Viking,u32&gt;= HashMap::new();
        
        vikings.insert(Viking::new(&quot;Einar&quot;, &quot;Norway&quot;), 25);
        vikings.insert(Viking::new(&quot;Olaf&quot;, &quot;Denmark&quot;), 24);
        vikings.insert(Viking::new(&quot;Harald&quot;, &quot;Iceland&quot;), 12);
        
        // Use derived implementation to print the status of the vikings.
        for (viking, health) in &amp;vikings {
            println!(&quot;{:?} has {} hp&quot;, viking, health);
        }
        println!(&quot;--------------------&quot;);
    
        for (key, value) in vikings.into_iter() {
            println!(&quot;{:?} = {}&quot;, key, value);
            //This line will cause error : safety
            // vikings.remove(key);
        }
    }
</code></pre></pre>
<h1><a class="header" href="#result-consumed" id="result-consumed">Result Consumed</a></h1>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
fn main() {
   let f = File::open(&quot;main.jpg&quot;);   // main.jpg doesn't exist
   match f {
      Ok(f)=&gt; {
         println!(&quot;file found {:?}&quot;,f);
      },
      Err(e)=&gt; {
         println!(&quot;file not found \n{:?}&quot;,e);   //handled error
      }
   }
   println!(&quot;end of main&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#some-none-example" id="some-none-example">Some None Example</a></h1>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Obj {
no:u128,
id:u128,
}

impl Obj{
   fn new(no:u128,id:u128)-&gt;Obj{
      Obj {
         no:no,
         id:id,
      }
   }
}         

fn main (){
let mut v:Vec&lt;Obj&gt; = Vec::new();
v.push(Obj::new(44, 68));

//-- lets get some here
match v.get(0) {
                  Some(x)=&gt; println!(&quot;{:?}--Result is success i.e Some&quot;,x.no),
                  None =&gt; println!(&quot;--Result is failure i.e None&quot;)
}

match v.get(20) {
                  Some(x)=&gt; println!(&quot;{:?}--Result is success i.e Some&quot;,x.no),
                  None =&gt; println!(&quot;--Result is failure i.e None&quot;)
} 

println!(&quot;{:?}&quot;,v.get(20));

}
</code></pre></pre>
<h1><a class="header" href="#struct-impl-example" id="struct-impl-example">Struct Impl Example</a></h1>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]

struct Rectangle {
    width:u32,
    height:u32,
}

impl Rectangle {
    fn area(&amp;self)-&gt; u32{
        self.width * self.height
    }
}

fn main(){

let rect = Rectangle {
    width:55,
    height:80,
};

println!(&quot;The area is :: {}&quot;, rect.area());

}//--main
</code></pre></pre>
<h1><a class="header" href="#struct-impl-example-2" id="struct-impl-example-2">Struct Impl Example-2</a></h1>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width:u32,
    height:u32,
}
impl Rectangle {
    fn area(&amp;self)-&gt; u32{
        self.width * self.height
    }
    fn can_hold(&amp;self,other:&amp;Rectangle)-&gt;bool{
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
//-------This is the second impl block for associative function (a static function). This does not take &amp;self rather take on other values.
impl Rectangle {
    fn square(size:u32)-&gt;Rectangle {
        Rectangle {
            width:size,
            height:size,
        }
    }
}
fn main(){
let rect01 = Rectangle {
    width:55,
    height:80,
};
let rect02 = Rectangle {
    width:22,
    height:10,
};
let rect03 = Rectangle {
    width:2,
    height:8,
};

println!(&quot;The area is :: {}&quot;, rect01.area());
println!(&quot;Can rect01 hold rect02 (hint:true)? {}&quot;, rect01.can_hold(&amp;rect02));
println!(&quot;Can rect01 hold rect03 (hint:true)? {}&quot;, rect01.can_hold(&amp;rect03));
println!(&quot;Can rect02 hold rect01 (hint:false)? {}&quot;, rect02.can_hold(&amp;rect01));
println!(&quot;Can rect03 hold rect01 (hint:false)? {}&quot;, rect03.can_hold(&amp;rect01));
//----------------------------------------------
//----------------------------------------------
println!(&quot;The associated/static fn :Rectangle::square(88):: {:?}&quot;, Rectangle::square(88));

}//--main
</code></pre></pre>
<h1><a class="header" href="#struct-impl-example-2-1" id="struct-impl-example-2-1">Struct Impl Example-2</a></h1>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width:u32,
    height:u32,
}
impl Rectangle {
    fn area(&amp;self)-&gt; u32{
        self.width * self.height
    }
    fn can_hold(&amp;self,other:&amp;Rectangle)-&gt;bool{
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
//-------This is the second impl block for associative function (a static function). This does not take &amp;self rather take on other values.
impl Rectangle {
    fn square(size:u32)-&gt;Rectangle {
        Rectangle {
            width:size,
            height:size,
        }
    }
}
fn main(){
let rect01 = Rectangle {
    width:55,
    height:80,
};
let rect02 = Rectangle {
    width:22,
    height:10,
};
let rect03 = Rectangle {
    width:2,
    height:8,
};

println!(&quot;The area is :: {}&quot;, rect01.area());
println!(&quot;Can rect01 hold rect02 (hint:true)? {}&quot;, rect01.can_hold(&amp;rect02));
println!(&quot;Can rect01 hold rect03 (hint:true)? {}&quot;, rect01.can_hold(&amp;rect03));
println!(&quot;Can rect02 hold rect01 (hint:false)? {}&quot;, rect02.can_hold(&amp;rect01));
println!(&quot;Can rect03 hold rect01 (hint:false)? {}&quot;, rect03.can_hold(&amp;rect01));
//----------------------------------------------
//----------------------------------------------
println!(&quot;The associated/static fn :Rectangle::square(88):: {:?}&quot;, Rectangle::square(88));

}//--main
</code></pre></pre>
<h1><a class="header" href="#struct-printing" id="struct-printing">Struct Printing</a></h1>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]    
struct Point {
    x:i32,
    y:i32,
}
fn main(){

let pt = Point {
    x:44, 
    y:66}; 

println!(&quot;{:?}&quot;,pt);
}//--main
</code></pre></pre>
<h1><a class="header" href="#sending-struct-to-a-function" id="sending-struct-to-a-function">Sending Struct to a Function</a></h1>
<p>** #edit I think variable names have not been capitalized correctly**</p>
<pre><pre class="playground"><code class="language-rust">struct Data {
    name:String,
    no1:u32,
    no2:u32,
}

fn main() {
let Data  = Data{
name : String::from(&quot;Mike&quot;),
no1 : 36,
no2 : 92,
};   


let result:u32 = add(&amp;Data);
println!(&quot;The name is  :: {}&quot;,Data.name);
println!(&quot;the result is :: {}&quot;,result);
}// main ends here

fn add(Data : &amp;Data)-&gt;u32{
    Data.no1+ Data.no2
}
</code></pre></pre>
<h1><a class="header" href="#system-time--time-stamp" id="system-time--time-stamp">System Time / Time Stamp</a></h1>
<pre><pre class="playground"><code class="language-rust">use std::time::SystemTime;

fn main() {
let time_now = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap();
println!(&quot;Finally the time stamp::{:?} &quot;,time_now);

}
</code></pre></pre>
<h1><a class="header" href="#thread-sleep" id="thread-sleep">Thread Sleep</a></h1>
<p>This is Test function using thread sleep. We can put a thread to sleep in test functions or in other code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use playhead::PlayHead;
use std::{thread, time};

#[test]
fn seq(){
    let mut ph = PlayHead::new();
    ph.play();
    let time_one = ph.time();

    let delay = time::Duration::from_millis(2000);
    thread::sleep(delay);
    
    let time_two = ph.time();
    //==========================
    ph.pause();
    thread::sleep(delay);
    let time_three = ph.time();

    assert!(time_two &gt; time_one);
    assert_eq!(time_two, time_three);
    // println!(&quot;Time after sleep=====&gt; {:?}&quot;,time_two - time_one);
}//fn
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#rust-documentation" id="rust-documentation">Rust Documentation</a></h1>
<ol>
<li>The standard Rust distribution ships with a tool called <strong>rustdoc</strong>. Its job is to generate documentation for Rust projects. On a fundamental level, Rustdoc takes as an argument either a crate root or a Markdown file, and produces HTML, CSS, and JavaScript.</li>
<li>We can use three forward slashes to write comments that will be included into documentation <strong>///</strong>.</li>
</ol>
<p>Here are some useful github commands which can really prove life savers.</p>
<h2><a class="header" href="#git-remove-origin" id="git-remove-origin">Git Remove Origin</a></h2>
<p>When ever we colne a respository we need to remove its connection from its previous remote repository.
There can be many other reasons to break the connection between some code present on your laptop and its current remote repository.</p>
<h4><a class="header" href="#to-remove-the-remote-repository" id="to-remove-the-remote-repository">To remove the remote repository</a></h4>
<pre><code>git remote remove origin
</code></pre>
<h4><a class="header" href="#to-add-a-new-remote-repository" id="to-add-a-new-remote-repository">To add a new remote repository</a></h4>
<pre><code>git remote add origin https://github.com/skillzaa/XXX.git
</code></pre>
<h1><a class="header" href="#creating-file" id="creating-file">Creating File</a></h1>
<p>================
Creating a Simple file.</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::Write;
fn main() {
    let file_name = &quot;test_doc.txt&quot;;
    let mut my_file = File::create(file_name).expect(&quot;creation failed&quot;);
    my_file.write_all(&quot;This is the first message&quot;.as_bytes()).expect(&quot;write failed&quot;);
    my_file.write_all(&quot; Keep working&quot;.as_bytes()).expect(&quot;write failed&quot;);
    println!(&quot;The file has been created and text has been added:)&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#reading-file" id="reading-file">Reading File</a></h1>
<p>It is as simple as that, even simpler than Javascript and PHP.</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;
fn main() {
    let file_name = &quot;test_doc.txt&quot;;
    let content = fs::read_to_string(file_name).unwrap();
    for line in content.lines() {
        println!(&quot;{}&quot;, line);
    }
}
</code></pre></pre>
<h1><a class="header" href="#serde-json" id="serde-json">Serde json</a></h1>
<p>This is an example of Serde serializing and deserializing vector of structs.</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::Write;
use serde::{Deserialize, Serialize};
use serde_json::Result;

#[derive(Serialize, Deserialize)]
#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

fn main() -&gt; Result&lt;()&gt; {
    deserialize()?;
    serialize()?;
   Ok(())
}
//========================
fn deserialize()-&gt;Result&lt;()&gt;{
     // Some JSON input data as a &amp;str. Maybe this comes from the user.
     let data = r#&quot;
     [{
         &quot;name&quot;: &quot;John Doe&quot;,
         &quot;age&quot;: 43
     },
     {
        &quot;name&quot;: &quot;Jane Michels&quot;,
        &quot;age&quot;: 35
    }]
     &quot;#;
 let pers: Vec&lt;Person&gt; = serde_json::from_str(data)?;
 println!(&quot;Pers {:?}&quot;, pers);

 Ok(())
}
fn serialize()-&gt;Result&lt;()&gt;{
    let mut j : Vec&lt;Person&gt; = Vec::new();
    j.push(Person { name: String::from(&quot;jill&quot;), age: 96 });
    j.push(Person { name: String::from(&quot;mike&quot;), age: 11 });
    j.push(Person { name: String::from(&quot;nikey&quot;), age: 33 });

    let pers:String = serde_json::to_string(&amp;j)?;
    println!(&quot;serialize {}&quot;,pers);
    Ok(())
}

</code></pre></pre>
<h1><a class="header" href="#quick-n-dirty-regex" id="quick-n-dirty-regex">Quick n Dirty Regex</a></h1>
<h3><a class="header" href="#my-understanding-of-multi-media-programming-as-of-21-oct-2021" id="my-understanding-of-multi-media-programming-as-of-21-oct-2021">My understanding of multi media programming as of 21-oct-2021</a></h3>
<p>I spent few hours of reading about multi media programming and found following</p>
<ol>
<li>The old technology (industry standerd) was <strong>OpenGL</strong> and that still stays.</li>
<li>OpenGL was extended to be usable in web space as <strong>WebGL</strong>.</li>
<li>OpenGL as well as WebGL both suffered from many problems and there was a need for a new API.</li>
<li><strong>Vulcan</strong> is the new low level API. It is the new thing and is very fast as compared to OpenGL. It provides a lot of power to the user.</li>
<li><em>I think vulcan make use of GPU for processing</em>.</li>
<li><strong>vulkano</strong> is the rust wrapper crate for Vulcan.</li>
<li>Just like WebGL was the web implementation of OpenGL similarly <strong>WebGPU is the web implementation of Vulcan</strong>. So WebGPU is the future of web graphics but is still under experimental flag.</li>
</ol>
<hr />
<h2><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h2>
<ol>
<li>For the time being material and tutorials on the Vulcan as well as WebGPU are very less.</li>
<li>It will NOT be a bad idea to try WebGL for a while since its available every where and is not being depricated anytime soon. Also the study material may be available a lot. also the basic techniques are the same.</li>
<li>You must learn Rust and then Webassembly first for that.  </li>
</ol>
<h1><a class="header" href="#2021-oct-15-rought-notes" id="2021-oct-15-rought-notes">2021-oct-15 Rought Notes</a></h1>
<p>Cargo is Rust’s build system and package manager.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ cargo --version
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#creating-a-project-with-cargo" id="creating-a-project-with-cargo">Creating a Project with Cargo</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ cargo new hello_cargo
$ cd hello_cargo
<span class="boring">}
</span></code></pre></pre>
<p>We set different flags in command line tools &quot;software that we run from command line&quot;. There must be a place where these values are stored however once a command line tool is installed we set the flags from command line and do not directly access the storage place / file. These flags are internal to the tool. On the other hand there are some command line tools that need the presence of some file to read data from e.g web-pack , gulp etc.</p>
<h3><a class="header" href="#to-run-project" id="to-run-project">To run project</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ cargo build // just build 
//or
$ cargo run // to build and run it
//or
$ cargo check // This command quickly checks your code to make sure it compiles but doesn’t produce an executable
//or
cargo build --release //  This command will create an executable in target/release instead of target/debug
<span class="boring">}
</span></code></pre></pre>
<p>Details about rust std library prelude @future. <a href="https://doc.rust-lang.org/std/prelude/index.html">https://doc.rust-lang.org/std/prelude/index.html</a>
Some of std library features are implicitly available by a special std::prelude that is automatically used (along with a reference to the std crate) without declaration. The prelude contains functionality that virtually all code is likely to use and therefore Rust spares code from having to import it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// You don't need these
extern crate std;
use std::prelude::*;
<span class="boring">}
</span></code></pre></pre>
<p>To use io lib you can</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io; //import the io lib
//or write directly
std::io::stdin;

<span class="boring">}
</span></code></pre></pre>
<p>Like variables, references are immutable by default
How to generate a random number</p>
<pre><pre class="playground"><code class="language-rust">use std::io;
use rand::Rng;

fn main() {   
    let secret_number = rand::thread_rng().gen_range(1..101);
    println!(&quot;The secret number is! {}&quot;,secret_number);
}
</code></pre></pre>
<ul>
<li>In the above code <strong>rand</strong> is crate,The <strong>Rng trait</strong> defines methods that random number generators implement, and this trait must be in scope for us to use those methods. The rand::thread_rng function will give us the particular random number generator that we’re going to use: one that is local to the current thread of execution and seeded by the operating system. Then we call the gen_range method on the random number generator. This method is defined by the Rng trait that we brought into scope with the use rand::Rng statement. The gen_range method takes a range expression as an argument and generates a random number in the range. The kind of range expression we’re using here takes the form start..end. It’s inclusive on the lower bound but exclusive on the upper bound, so we need to specify 1..101 to request a number between 1 and 100. Alternatively, we could pass the range 1..=100, which is equivalent. 
Have a look at rust std crate documentation <a href="https://docs.rs/rustc-std-workspace-std/1.0.1/std/">https://docs.rs/rustc-std-workspace-std/1.0.1/std/</a></li>
</ul>
<h3><a class="header" href="#a-tour-of-the-rust-standard-library" id="a-tour-of-the-rust-standard-library">A Tour of The Rust Standard Library</a></h3>
<p><a href="http://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/std/index.html">http://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/std/index.html</a></p>
<h3><a class="header" href="#very-informative-rust-beginners-book" id="very-informative-rust-beginners-book">Very informative Rust Beginners book</a></h3>
<p><a href="https://stevedonovan.github.io/rust-gentle-intro/object-orientation.html">https://stevedonovan.github.io/rust-gentle-intro/object-orientation.html</a></p>
<h3><a class="header" href="#comparing-number" id="comparing-number">Comparing Number</a></h3>
<pre><pre class="playground"><code class="language-rust">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre></pre>
<p>Rust has a strong, static type system. However, it also has type inference
Rust is a statically and strongly typed systems programming language. statically means that all types are known at compile-time, strongly means that these types are designed to make it harder to write incorrect programs.</p>
<h3><a class="header" href="#shadowing" id="shadowing">Shadowing</a></h3>
<p>Shadowing is different from marking a variable as mut, because we’ll get a compile-time error if we accidentally try to reassign to this variable without using the let keyword. By using let, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed.</p>
<p>The other difference between mut and shadowing is that because we’re effectively creating a new variable when we use the let keyword again, we can change the type of the value but reuse the same name. For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, but we really want to store that input as a number:
Rust is a statically typed language, which means that it must know the types of all variables at compile time.</p>
<hr />
<h3><a class="header" href="#data-types" id="data-types">Data types.</a></h3>
<h4><a class="header" href="#scalar-types" id="scalar-types">Scalar Types</a></h4>
<p>A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. </p>
<h4><a class="header" href="#compound-types" id="compound-types">Compound Types</a></h4>
<p>Compound types can group multiple values into one type. Rust has two primitive compound types: tuples and arrays.</p>
<h4><a class="header" href="#the-tuple-type" id="the-tuple-type">The Tuple Type</a></h4>
<p>A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>To extract tuple values</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>We can access a tuple element directly by using a period (.)</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<h4><a class="header" href="#the-array-type" id="the-array-type">The Array Type</a></h4>
<p>Another way to have a collection of multiple values is with an array. Unlike a tuple, every element of an array must have the same type. Arrays in Rust are different from arrays in some other languages because arrays in Rust have a fixed length, like tuples.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
    //or
    let a: [i32; 5] = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>An array isn’t as flexible as the vector type, though. A vector is a similar collection type provided by the standard library that is allowed to grow or shrink in size. </p>
<blockquote>
<p>Array are stack allocated and can not grow or shrink, where as a vector is heap allocated and thus can grow or shrink.
An example of when you might want to use an array rather than a vector is in a program that needs to know the names of the months of the year. It’s very unlikely that such a program will need to add or remove months, so you can use an array because you know it will always contain 12 elements.</p>
</blockquote>
<h4><a class="header" href="#accessing-array-elements" id="accessing-array-elements">Accessing Array Elements</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<h2><a class="header" href="#if-we-provide-wrong-index-to-an-array-that-will-be-a-run-time-error" id="if-we-provide-wrong-index-to-an-array-that-will-be-a-run-time-error">If we provide wrong index to an array that will be a <strong>run time error</strong></a></h2>
<h2><a class="header" href="#functions" id="functions">Functions</a></h2>
<p>Function bodies are made up of a series of statements optionally ending in an expression. </p>
<ul>
<li>Statements are instructions that perform some action and do not return a value. </li>
<li>Expressions evaluate to a resulting value.</li>
<li>Function definitions are also statements.
Statements do not return values. Therefore, you can’t assign a let statement to another variable, as the following code tries to do; you’ll get an error. The let y = 6 statement does not return a value, so there isn’t anything for x to bind to. This is different from what happens in other languages, such as C and Ruby, where the assignment returns the value of the assignment. In those languages, you can write x = y = 6 and have both x and y have the value 6; that is not the case in Rust.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = (let y = 6);
}
</code></pre></pre>
<p>Expressions evaluate to something and make up most of the rest of the code that you’ll write in Rust. Consider a simple math operation, such as 5 + 6, which is an expression that evaluates to the value 11.Expressions can be part of statements
Calling a function is an expression. Calling a macro is an expression. The block that we use to create new scopes, {}, is an expression</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<blockquote>
<p>In Rust, the return value of the function is synonymous with the value of the final expression in the block of the body of a function. You can return early from a function by using the return keyword and specifying a value, but most functions return the last expression implicitly.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<ul>
<li>There are no function calls, macros, or even let statements in the five function—just the number 5 by itself. That’s a perfectly valid function in Rust. Note that the function’s return type is specified too, as -&gt; i32. </li>
</ul>
<hr />
<h3><a class="header" href="#oop-in-rust" id="oop-in-rust">OOP in Rust</a></h3>
<p>The relationships between various data types in Rust are established using traits. <strong>A large part of learning Rust is understanding how the standard library traits operate</strong>, because that's the web of meaning that glues all the data types together.</p>
<p><em>Traits are interesting because there's no one-to-one correspondence between them and concepts from mainstream languages</em>. It depends if </p>
<p>So Rust traits allow traditional polymorphic OOP. But what about inheritance? People usually mean implementation inheritance whereas Rust does interface inheritance.</p>
<p>Implementation inheritance has some serious problems. But it does feel so very convenient. There's this fat base class called Animal and it has loads of useful functionality (it may even expose its innards!) which our derived class Cat can use. That is, it is a form of code reuse. But code reuse is a separate concern.</p>
<p>Getting the distinction between implementation and interface inheritance is important when understanding Rust.</p>
<p>Note that traits may have provided methods. Consider Iterator - you only have to override next, but get a whole host of methods free. This is similar to 'default' methods of modern Java interfaces. Here we only define name and upper_case is defined for us. We could override upper_case as well, but it isn't required.</p>
<blockquote>
<p>In rust vectors and arrays can only have one data type, there can not be an array or vector of strings and int. Further more vectors can grow and shrink where as arrays dont. A struct on the other hand is used to mix and match different data types and thus contain any number of arrays and vectors.</p>
</blockquote>
<hr />
<h3><a class="header" href="#traits-as-parameters-and-the-trait-bound-syntax" id="traits-as-parameters-and-the-trait-bound-syntax">Traits as Parameters, and the Trait Bound Syntax</a></h3>
<p>At this point, you might be asking - “Why is this useful? I mean, why don’t we just drop the trait bits and just declare this method under a regular old impl Person block?”</p>
<p>As alluded to at the end of the previous section, the primary reason we focus on defining and then implementing certain behavior, is that we can then build APIs that are behavior-centric, and not just type-centric. Rather than building functions that only accept a certain, predefined type, we can build functions that instead allow any type to be passed in, provided they implement a certain behavior, or set of behaviors. In other words, you can use Traits in the place of concrete types, such as in function parameters.</p>
<h1><a class="header" href="#2021-oct-16-traits-in-rust" id="2021-oct-16-traits-in-rust">2021-oct-16 Traits in Rust</a></h1>
<h3><a class="header" href="#definition" id="definition">Definition</a></h3>
<blockquote>
<p>A trait is a collection of methods defined for an unknown type: Self. They can access other methods declared in the same trait.Traits can be implemented for any data type.</p>
</blockquote>
<hr />
<blockquote>
<p>A trait tells the Rust compiler about functionality a particular type has and can share with other types.We can use traits to define shared behavior in an abstract way.</p>
</blockquote>
<hr />
<blockquote>
<p>Traits are similar to a feature often called interfaces in other languages, although with some differences.</p>
</blockquote>
<hr />
<ul>
<li>When an object implements a trait it has to provide implementation for those methods for which default implementation is not provided. For methods which default implementation is provided can be over written or accepted.</li>
</ul>
<hr />
<blockquote>
<p>A type’s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</p>
</blockquote>
<hr />
<ul>
<li>Before using a trait we need to bring the trait into scope first.*Which means that this trait needs to be public in its own defined crate.</li>
<li>One restriction to note with trait implementations is that we can implement a trait on a type only if either the trait or the type is local to our crate (means declared in that craten).We can’t implement external traits on external types</li>
</ul>
<h4><a class="header" href="#what-is-dynamic-dispatch" id="what-is-dynamic-dispatch">What is Dynamic Dispatch</a></h4>
<p>In computer science, dynamic dispatch is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time. It is commonly employed in, and considered a prime characteristic of, object-oriented programming (OOP) languages and systems.
<strong>Polymorphism is the phenomenon wherein somewhat interchangeable objects each expose an operation of the same name but possibly differing in behavior</strong>
OR
<strong>polymorphism gives us the ability to present a single interface for potentially many different concrete types. This allows us to create more flexible APIs which give more control to the consumer and are easier to maintain.There are several practical advantages to using polymorphism, but one of the biggest is code re-use. If you design an API around specific, concrete types, then you’re committed to that approach, and so are your consumers.</strong></p>
<ul>
<li>We should keep the behaviour seperate from data so that it is flexable.</li>
<li>Polymorphism allows us to create functions that accept any type, as long as those types exhibit certain behaviors or properties that we need them to have.
<br/>
<img src="rough_notes/./images/polymorphism.png">
In this case, that behavior is actually all we care about, so we can leverage polymorphism to be more flexible, but maintain a set of required functionality. Through this, we can do things like write a single function that accepts multiple types.
<a href="https://oswalt.dev/2021/06/polymorphism-in-rust/">credit</a>
This is the general idea behind why we would want to use polymorphism in any language, but what options for polymorphism exist in Rust? There are two primary ways, and both of these have trade-offs to consider when it comes to performance as well as binary size:</li>
</ul>
<p><strong>Static Dispatch</strong> </p>
<ul>
<li>this approach leverages generics (also called parametric polymorphism) and (usually) trait bounds to provide the flexibility we need while still maintaining full type safety, and without requiring a lot of duplicate code. This approach is extremely performant (in Rust this is known as a “zero-cost abstraction”) - however, due to monomorphization, this does create a larger binary size.</li>
</ul>
<p><strong>Dynamic Dispatch</strong> </p>
<ul>
<li>this approach uses “trait objects” to punt the decision of which type is required to satisfy some kind of polymorphic interface to runtime. This cuts down on binary size (as no monomorphization is used here) but incurs a performance penalty due to the extra lookup at runtime. This approach also explicitly forbids the use of generics.</li>
<li>Dynamic dispatch can be characterized as the opposite of static dispatch. Where static dispatch choses to create copies of all functions that use generic parameters and store these in the binary, dynamic dispatch choses to store only a single copy, but then calculates the necessary concrete implementation at runtime.</li>
<li>In Rust, dynamic dispatch leverages “Trait Objects” to achieve polymorphism. Unlike trait bounds, which is an optional constraint you can add to generic parameters, trait objects actually cannot be used with generics at all, and instead are the required method for performing dynamic dispatch in Rust.The syntax for trait objects these days is characterized by the dyn keyword, followed by the name of a Trait</li>
<li>The dyn keyword was introduced in Rust 1.27 and is now the idiomatic way to explicitly specify that you wish to use dynamic dispatch through trait object.</li>
<li>Even though we’re not using generic parameters, the compiler still needs a little help to know the size of our types at compile-time. This is why you’ll commonly see trait bounds passed in via reference.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dynamic_dispatch(t: &amp;dyn Growler) {
    t.growl();
}
<span class="boring">}
</span></code></pre></pre>
<hr />
<h3><a class="header" href="#traits-as-parameters-trait-bounds" id="traits-as-parameters-trait-bounds">Traits as Parameters (trait bounds)</a></h3>
<p><em>When we want to base our code on behaviour and not data type we specify a trait as an argument to a function</em> (and not a data type). In this way we can give this function any data type as long as that data type implements that trait.
We normally create a Vector and wrap it in <strong>Box</strong> with <strong>dyn</strong> key word. </p>
<h3><a class="header" href="#trait-object" id="trait-object">Trait Object</a></h3>
<p>A trait object points to both an instance of a type implementing our specified trait as well as a table used to look up trait methods on that type at runtime But trait objects differ from traditional objects in that we can’t add data to a trait object. Trait objects aren’t as generally useful as objects in other languages: their specific purpose is to allow abstraction across common behavior.</p>
<blockquote>
<p>Trait objects are more like objects in other languages in the sense that they combine data and behavior.
We create a trait object by specifying some sort of pointer, such as a &amp; reference or a Box<T> smart pointer, then the dyn keyword, and then specifying the relevant trait. Trait objects must use a pointer.</p>
</blockquote>
<ul>
<li>Trait objects can be thought of like objects of an Interface Type in Java, defining common functionality for the Types implementing them. When using a trait object, we don’t care what exact type is used, we just make sure that given functionality is present.</li>
</ul>
<hr />
<blockquote>
<p>‘Monomorphization’ a fancy term for saying the compiler fills in the concrete types for the generic ones at compile time and duplicates the code if necessary. </p>
</blockquote>
<hr />
<h3><a class="header" href="#conclusion-1" id="conclusion-1">Conclusion</a></h3>
<ul>
<li>We use trait bounds (Traits as Parameters) with static dispatch along with generics. We get a seperate fn for each type at compile time.</li>
<li>We use trait objects for dynamic dispatch. In this we use the <strong>dyn</strong> keyword and we do not use generics. A <strong>v table</strong> is used. </li>
</ul>
<hr />
<hr />
<h2><a class="header" href="#notes" id="notes">Notes</a></h2>
<p>The problem with inheretence is that the complexity increase exponenetially.
In Rust the emphasis is on composition and not inheretance. Code reuse is made sure using composition and not inheretance.
Traits are a way to share behaviour between different different structs/?. 
In my experience, default implementations are most useful when I am creating the trait and the types that use that trait’s implementation. This is a way of reducing unnecessarily duplicated code, primarily. The vast majority of the times I’ve seen traits as part of an external crate’s (library) API, it required me to provide implementations for them, as a way of forcing me to really define how I expect that behavior to be expressed in my codebase.
<a href="https://oswalt.dev/2020/07/rust-traits-defining-behavior/">https://oswalt.dev/2020/07/rust-traits-defining-behavior/</a></p>
<blockquote>
<p>Trait can also be returned from a function. It means that the trait (the behaviour) can be decided at run time. This changes everything.</p>
</blockquote>
<h1><a class="header" href="#faqs-1" id="faqs-1">FAQs</a></h1>
<ol>
<li>What is the difference between an array in rust and tuples.</li>
</ol>
<h2><a class="header" href="#life-savers" id="life-savers">Life Savers</a></h2>
<ol>
<li>To run tests with displaying println comments use</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo test -- --nocapture
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>Before uploading to crates.io try it with a dry run.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo publish --dry-run
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
